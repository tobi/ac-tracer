-- state.lua - Centralized game state
-- All state and persistence lives here. Other modules read from state.

local lap = require('lap')

local state = {}

--------------------------------------------------------------------------------
-- State Structure
--------------------------------------------------------------------------------

-- Session info (set once at start)
state.track = nil              -- string: track ID
state.car = nil                -- string: car ID
state.sessionId = nil          -- string: unique ID for this session

-- Track data
state.trackCorners = {}        -- array of corner definitions

-- Current position (updated every frame)
state.lapNumber = 0            -- number: current lap count
state.trackPosition = 0        -- number: spline position 0.0-1.0

-- Lap data
state.currentLap = nil         -- lap: being recorded
state.history = {}             -- array[lap]: completed laps (max 20, persisted)
state.historyReferences = {}   -- array[lap]: external CSVs loaded for comparison

-- Reference lap
state.bestLap = nil            -- lap: current reference for ghost comparison
state.bestLapCorners = {}      -- pre-computed corner analysis for bestLap

-- Manual corner recording
state.cornerRecording = false
state.cornerRecordStart = nil
state.cornerRecordTime = nil

--------------------------------------------------------------------------------
-- Constants
--------------------------------------------------------------------------------

local SAMPLE_RATE = lap.SAMPLE_RATE
local MAX_HISTORY = 20
local TAP_THRESHOLD = 1.0

-- Timing
local sampleTimer = 0
local initialized = false

--------------------------------------------------------------------------------
-- Storage Keys
--------------------------------------------------------------------------------

local function getStorageKey(suffix)
    local trackId = state.track or 'unknown'
    return 'traces_' .. trackId:gsub("[/\\:]", "_") .. '_' .. suffix
end

local function getTrackFileName()
    if not state.track then return nil end
    return state.track:gsub("[/\\:*?\"<>|]", "_")
end

local function getCornersFilePath()
    local fileName = getTrackFileName()
    if not fileName then return nil end
    return __dirname .. "/tracks/" .. fileName .. "_corners.lua"
end

--------------------------------------------------------------------------------
-- Persistence: Corners
--------------------------------------------------------------------------------

--- Save corners to Lua file
local function saveCornersToFile()
    local filePath = getCornersFilePath()
    if not filePath then return false end
    if not state.trackCorners or #state.trackCorners == 0 then return false end
    
    local lines = {
        "-- Corner data for track: " .. (state.track or "unknown"),
        "-- Generated by Traces app",
        "return {"
    }
    
    for i, corner in ipairs(state.trackCorners) do
        if corner.startPos and corner.endPos then
            table.insert(lines, string.format("    {%.6f, %.6f},  -- Corner %d", 
                corner.startPos, corner.endPos, corner.number or i))
        else
            table.insert(lines, string.format("    {},  -- Skip %d", i))
        end
    end
    
    table.insert(lines, "}")
    
    local f = io.open(filePath, "w")
    if f then
        f:write(table.concat(lines, "\n"))
        f:close()
        ac.log("Traces: Saved corners to " .. filePath)
        return true
    end
    return false
end

--- Load corners from Lua file
local function loadCornersFromFile()
    local filePath = getCornersFilePath()
    if not filePath then return false end
    
    local f = io.open(filePath, "r")
    if not f then return false end
    
    local content = f:read("*a")
    f:close()
    
    if not content or content == "" then return false end
    
    local fn, err = load(content, filePath, "t", {})
    if not fn then
        ac.log("Traces: Failed to parse corners: " .. tostring(err))
        return false
    end
    
    local ok, result = pcall(fn)
    if not ok or type(result) ~= "table" then return false end
    
    -- Convert pairs to corner structure
    state.trackCorners = {}
    for i, pair in ipairs(result) do
        if pair and #pair == 2 then
            local startPos, endPos = pair[1], pair[2]
            local apexPos = (startPos + endPos) / 2
            if endPos < startPos then
                apexPos = (startPos + endPos + 1) / 2
                if apexPos >= 1 then apexPos = apexPos - 1 end
            end
            table.insert(state.trackCorners, {
                number = i,
                startPos = startPos,
                endPos = endPos,
                apexPos = apexPos
            })
        end
    end
    
    ac.log("Traces: Loaded " .. #state.trackCorners .. " corners from file")
    return true
end

--- Save corners to ac.storage
local function saveCornersToStorage()
    local key = getStorageKey('corners')
    if state.trackCorners and #state.trackCorners > 0 then
        local pairs = {}
        for _, c in ipairs(state.trackCorners) do
            if c.startPos and c.endPos then
                table.insert(pairs, {c.startPos, c.endPos})
            else
                table.insert(pairs, {})
            end
        end
        ac.storage[key] = stringify(pairs)
    else
        ac.storage[key] = nil
    end
end

--- Load corners from ac.storage
local function loadCornersFromStorage()
    local key = getStorageKey('corners')
    local data = ac.storage[key]
    if not data then return false end
    
    local ok, pairs = pcall(function() return stringify.parse(data) end)
    if not ok or not pairs then return false end
    
    state.trackCorners = {}
    for i, pair in ipairs(pairs) do
        if pair and #pair == 2 then
            local startPos, endPos = pair[1], pair[2]
            local apexPos = (startPos + endPos) / 2
            if endPos < startPos then
                apexPos = (startPos + endPos + 1) / 2
                if apexPos >= 1 then apexPos = apexPos - 1 end
            end
            table.insert(state.trackCorners, {
                number = i,
                startPos = startPos,
                endPos = endPos,
                apexPos = apexPos
            })
        end
    end
    
    ac.log("Traces: Loaded " .. #state.trackCorners .. " corners from storage")
    return true
end

--------------------------------------------------------------------------------
-- Persistence: Best Lap
--------------------------------------------------------------------------------

--- Save best lap to ac.storage
local function saveBestLap()
    if not state.bestLap then return end
    
    local key = getStorageKey('bestlap')
    ac.storage[key] = state.bestLap:serialize()
    ac.storage[getStorageKey('bestlap_time')] = tostring(state.bestLap.time)
    ac.log("Traces: Saved best lap to storage")
end

--- Load best lap from ac.storage
local function loadBestLap()
    local key = getStorageKey('bestlap')
    local data = ac.storage[key]
    if not data then return false end
    
    local loaded = lap.deserialize(data)
    if loaded and loaded:length() > 10 then
        state.bestLap = loaded
        ac.log("Traces: Loaded best lap from storage")
        return true
    end
    return false
end

--------------------------------------------------------------------------------
-- Persistence: History
--------------------------------------------------------------------------------

--- Save history to ac.storage
local function saveHistory()
    if not state.history or #state.history == 0 then return end
    
    local serialized = {}
    for i, lapData in ipairs(state.history) do
        if i <= MAX_HISTORY then
            table.insert(serialized, lapData:serialize())
        end
    end
    
    local key = getStorageKey('history')
    ac.storage[key] = stringify(serialized)
    ac.log("Traces: Saved " .. #serialized .. " laps to history")
end

--- Load history from ac.storage
local function loadHistory()
    local key = getStorageKey('history')
    local data = ac.storage[key]
    if not data then return false end
    
    local ok, serialized = pcall(function() return stringify.parse(data) end)
    if not ok or not serialized then return false end
    
    state.history = {}
    for _, lapStr in ipairs(serialized) do
        local loaded = lap.deserialize(lapStr)
        if loaded and loaded:length() > 10 then
            table.insert(state.history, loaded)
        end
    end
    
    ac.log("Traces: Loaded " .. #state.history .. " laps from history")
    return #state.history > 0
end

--------------------------------------------------------------------------------
-- Auto-Detection: Corners from Best Lap
--------------------------------------------------------------------------------

-- Detection parameters
local SPEED_DROP_THRESHOLD = 0.25
local BRAKE_THRESHOLD = 0.15
local THROTTLE_ON_THRESHOLD = 0.7
local LEAD_DISTANCE = 50
local EXIT_TIME = 2.0
local EXIT_TIME_THROTTLE_ONLY = 5.0
local STEERING_CENTER_THRESHOLD = 0.042  -- ~15Â°

local function isSteeringCentered(steeringNorm)
    return math.abs(steeringNorm - 0.5) < STEERING_CENTER_THRESHOLD
end

--- Auto-detect corners from a lap's telemetry
---@param lapData table Lap instance
---@return table Array of corner definitions
local function autoDetectCorners(lapData)
    if not lapData or lapData:length() < 30 then return {} end

    local trackLength = ac.getSim().trackLengthM or 5000
    local leadSpline = LEAD_DISTANCE / trackLength

    local corners = {}
    local i = 1
    local cornerNum = 0
    local numSamples = lapData:length()

    while i < numSamples do
        local brake = lapData.brake[i]
        local pos = lapData.pos[i]
        local speed = lapData.speed[i]

        if brake >= BRAKE_THRESHOLD then
            local brakePos = pos
            local entryIdx = i
            local maxSpeedBeforeBrake = speed

            -- Look back for entry point
            local j = i - 1
            while j >= 1 do
                if lapData.speed[j] > maxSpeedBeforeBrake then
                    maxSpeedBeforeBrake = lapData.speed[j]
                end
                local posDiff = brakePos - lapData.pos[j]
                if posDiff < 0 then posDiff = posDiff + 1 end
                if posDiff >= leadSpline then
                    entryIdx = j
                    break
                end
                j = j - 1
            end

            -- Find apex (minimum speed)
            local apexIdx = i
            local apexSpeed = speed
            local k = i + 1
            while k <= numSamples do
                if lapData.speed[k] < apexSpeed then
                    apexSpeed = lapData.speed[k]
                    apexIdx = k
                end
                if lapData.speed[k] > apexSpeed * 1.3 then break end
                k = k + 1
            end

            -- Check if qualifies as corner
            local speedDrop = (maxSpeedBeforeBrake - apexSpeed) / maxSpeedBeforeBrake
            if speedDrop >= SPEED_DROP_THRESHOLD and maxSpeedBeforeBrake > 50 then
                -- Find exit
                local exitIdx = apexIdx
                local exitConditionStart = nil
                local throttleOnlyStart = nil
                local apexTime = (apexIdx - 1) / lap.SAMPLE_RATE

                for m = apexIdx, numSamples do
                    local sTime = (m - 1) / lap.SAMPLE_RATE
                    local sThrottle = lapData.throttle[m]
                    local sSteering = lapData.steering[m]

                    if isSteeringCentered(sSteering) and sThrottle >= THROTTLE_ON_THRESHOLD then
                        if not exitConditionStart then exitConditionStart = sTime end
                        if (sTime - exitConditionStart) >= EXIT_TIME then
                            exitIdx = m
                            break
                        end
                    else
                        exitConditionStart = nil
                    end

                    if sThrottle >= THROTTLE_ON_THRESHOLD then
                        if not throttleOnlyStart then throttleOnlyStart = sTime end
                        if (sTime - throttleOnlyStart) >= EXIT_TIME_THROTTLE_ONLY then
                            exitIdx = m
                            break
                        end
                    else
                        throttleOnlyStart = nil
                    end

                    if (sTime - apexTime) > 15 then
                        exitIdx = m
                        break
                    end
                end

                -- Smart merge check
                local shouldMerge = false
                if #corners > 0 then
                    local prevCorner = corners[#corners]
                    local hadStraight = false
                    for idx = prevCorner.endIdx or 1, entryIdx do
                        if idx <= numSamples then
                            local steering = lapData.steering[idx]
                            local throttle = lapData.throttle[idx]
                            if isSteeringCentered(steering) and throttle >= THROTTLE_ON_THRESHOLD then
                                hadStraight = true
                                break
                            end
                        end
                    end
                    if not hadStraight then
                        shouldMerge = true
                        prevCorner.endIdx = exitIdx
                        prevCorner.endPos = lapData.pos[exitIdx]
                        if apexSpeed < (prevCorner.apexSpeed or 999) then
                            prevCorner.apexPos = lapData.pos[apexIdx]
                            prevCorner.apexSpeed = apexSpeed
                        end
                    end
                end

                if not shouldMerge then
                    cornerNum = cornerNum + 1
                    table.insert(corners, {
                        number = cornerNum,
                        startPos = lapData.pos[entryIdx],
                        endPos = lapData.pos[exitIdx],
                        apexPos = lapData.pos[apexIdx],
                        endIdx = exitIdx,
                        apexSpeed = apexSpeed
                    })
                end

                i = exitIdx + 1
            else
                i = i + 1
            end
        else
            i = i + 1
        end
    end

    -- Clean up internal fields
    for _, c in ipairs(corners) do
        c.endIdx = nil
        c.apexSpeed = nil
    end

    ac.log("Traces: Auto-detected " .. #corners .. " corners from lap")
    return corners
end

-- Track if we've auto-detected for this best lap
local lastAutoDetectLap = nil

--- Update auto-detected corners when best lap changes
local function updateAutoDetectedCorners()
    -- Only auto-detect if no manual corners are defined
    if state.trackCorners and #state.trackCorners > 0 then
        return  -- Manual corners exist, don't overwrite
    end
    
    -- Only auto-detect if we have a best lap
    if not state.bestLap then
        return
    end
    
    -- Only auto-detect once per best lap
    if lastAutoDetectLap == state.bestLap then
        return
    end
    
    lastAutoDetectLap = state.bestLap
    state.trackCorners = autoDetectCorners(state.bestLap)
end

--------------------------------------------------------------------------------
-- Initialization
--------------------------------------------------------------------------------

--- Initialize state for current session
---@param car table Car state from ac.getCar()
function state.init(car)
    if initialized then return end
    
    state.track = ac.getTrackID()
    state.car = car.id
    state.sessionId = tostring(os.time()) .. "_" .. tostring(math.random(1000, 9999))
    state.lapNumber = car.lapCount
    state.trackPosition = car.splinePosition
    
    ac.log("Traces: Session ID: " .. state.sessionId)
    
    -- Load corners (file first, then storage)
    if not loadCornersFromFile() then
        loadCornersFromStorage()
    end
    
    -- Load best lap and history
    loadBestLap()
    loadHistory()
    
    -- Auto-detect corners if no manual corners and we have a best lap
    updateAutoDetectedCorners()
    
    -- Initialize current lap
    state.currentLap = lap.new(state.track, state.car, state.sessionId)
    state.currentLap.fuelLeftAtStart = car.fuel
    
    initialized = true
    ac.log('Traces: State initialized for ' .. state.track)
end

--------------------------------------------------------------------------------
-- Update Loop
--------------------------------------------------------------------------------

--- Update state (call from script.update)
---@param dt number Delta time in seconds
---@param car table Car state from ac.getCar()
function state.update(dt, car)
    if not car then return end
    
    -- Initialize on first run
    state.init(car)
    
    -- Skip if paused
    if ac.getSim().isPaused then return end
    
    -- Sample at 15 Hz
    sampleTimer = sampleTimer + dt
    if sampleTimer >= 1 / SAMPLE_RATE then
        sampleTimer = sampleTimer - 1 / SAMPLE_RATE
        
        -- Ensure current lap exists
        if not state.currentLap then
            state.currentLap = lap.new(state.track, state.car, state.sessionId)
            state.currentLap.fuelLeftAtStart = car.fuel
        end
        
        -- Add sample if valid
        if car.lapTimeMs > 0 and car.splinePosition >= 0 then
            state.currentLap:addSample(car)
        end
    end
    
    -- Check lap completion
    if car.lapCount > state.lapNumber then
        if state.lapNumber > 0 and state.currentLap and state.currentLap:length() > 10 then
            -- Finalize completed lap
            state.currentLap.completed = true
            state.currentLap.valid = car.isLastLapValid
            state.currentLap.time = car.previousLapTimeMs
            
            -- Add to history (most recent first)
            table.insert(state.history, 1, state.currentLap)
            while #state.history > MAX_HISTORY do
                table.remove(state.history)
            end
            saveHistory()
            
            -- Update best lap if this is faster and valid
            if state.currentLap.valid and state.currentLap.time > 0 then
                if not state.bestLap or state.currentLap.time < state.bestLap.time then
                    state.bestLap = state.currentLap
                    state.bestLapCorners = state.analyzeCorners(state.currentLap)
                    saveBestLap()
                    updateAutoDetectedCorners()
                    ac.log('Traces: New best lap: ' .. (state.currentLap.time / 1000) .. 's')
                end
            end
        end
        
        -- Reset for new lap
        state.currentLap = lap.new(state.track, state.car, state.sessionId)
        state.currentLap.fuelLeftAtStart = car.fuel
        state.lapNumber = car.lapCount
    end
    
    -- Update position
    state.trackPosition = car.splinePosition
end

--------------------------------------------------------------------------------
-- Ghost/Best Lap API
--------------------------------------------------------------------------------

--- Get current delta vs best lap
---@return number Delta in seconds (positive = slower)
function state.getDelta()
    if not state.currentLap or not state.bestLap then return 0 end
    return state.currentLap:getDeltaVs(state.bestLap, state.trackPosition)
end

--- Get ghost steering at current position
---@return number|nil Steering in degrees
function state.getGhostSteering()
    if not state.bestLap then return nil end
    local steerNorm = state.bestLap:getValueAtPos('steering', state.trackPosition)
    if not steerNorm then return nil end
    return lap.steerToDegrees(steerNorm)
end

--- Get ghost traces for display positions
---@param positions table Array of spline positions
---@return table|nil Traces { throttle={}, brake={}, ... }
function state.getGhostTraces(positions)
    if not state.bestLap then return nil end
    return state.bestLap:getTracesAt(positions)
end

--- Check if we have a best lap
---@return boolean
function state.hasBestLap()
    return state.bestLap ~= nil and state.bestLap:length() > 10
end

--- Get best lap time in seconds
---@return number|nil
function state.getBestLapTime()
    if not state.bestLap then return nil end
    return state.bestLap.time / 1000
end

--- Get best lap data
---@return table|nil
function state.getBestLap()
    return state.bestLap
end

--- Get fastest lap from current session only
---@return table|nil lap, number|nil index
function state.getFastestSessionLap()
    if not state.history or #state.history == 0 then return nil, nil end
    if not state.sessionId then return nil, nil end
    
    local fastest = nil
    local fastestIdx = nil
    for i, lapData in ipairs(state.history) do
        -- Only consider laps from current session
        if lapData.sessionId == state.sessionId and 
           lapData.valid and lapData.time and lapData.time > 0 then
            if not fastest or lapData.time < fastest.time then
                fastest = lapData
                fastestIdx = i
            end
        end
    end
    return fastest, fastestIdx
end

--- Set best lap directly
---@param lapData table Lap instance
function state.setBestLap(lapData)
    state.bestLap = lapData
    state.bestLapCorners = state.analyzeCorners(lapData)
    saveBestLap()
    updateAutoDetectedCorners()
end

--- Reset best lap
function state.resetBestLap()
    state.bestLap = nil
    state.bestLapCorners = {}
    ac.storage[getStorageKey('bestlap')] = nil
    ac.storage[getStorageKey('bestlap_time')] = nil
    ac.log("Traces: Reset best lap")
end

--- Get ghost value at position (for corner analysis)
---@param field string Field name
---@param pos number Spline position
---@return number|nil
function state.getGhostValueAt(field, pos)
    if not state.bestLap then return nil end
    return state.bestLap:getValueAtPos(field, pos)
end

--- Get ghost time at position
---@param pos number Spline position
---@return number|nil Time in seconds
function state.getGhostTimeAtPos(pos)
    if not state.bestLap then return nil end
    return state.bestLap:getTimeAtPos(pos)
end

--- Get max steering in range from best lap
---@param startPos number
---@param endPos number
---@return number Degrees
function state.getGhostMaxSteeringInRange(startPos, endPos)
    if not state.bestLap then return 0 end
    return state.bestLap:findMaxSteering(startPos, endPos)
end

--- Get brake point in range from best lap
---@param startPos number
---@param endPos number
---@return number|nil
function state.getGhostBrakePointInRange(startPos, endPos)
    if not state.bestLap then return nil end
    return state.bestLap:findBrakePoint(startPos, endPos)
end

--- Get lift-off point in range from best lap
---@param startPos number
---@param endPos number
---@return number|nil
function state.getGhostLiftPointInRange(startPos, endPos)
    if not state.bestLap then return nil end
    return state.bestLap:findLiftPoint(startPos, endPos)
end

--- Get apex (minimum speed point) in range from best lap
---@param startPos number
---@param endPos number
---@return number|nil apexPos
---@return number|nil apexSpeed
function state.getGhostApexInRange(startPos, endPos)
    if not state.bestLap then return nil, nil end
    return state.bestLap:findApex(startPos, endPos)
end

--------------------------------------------------------------------------------
-- Corner Management
--------------------------------------------------------------------------------

--- Analyze corners for a lap
---@param lapData table Lap instance
---@return table Corner analysis data
function state.analyzeCorners(lapData)
    if not lapData or not state.trackCorners then return {} end
    
    local analysis = {}
    for _, corner in ipairs(state.trackCorners) do
        analysis[corner.number] = {
            entrySpeed = lapData:getValueAtPos('speed', corner.startPos),
            apexSpeed = lapData:getValueAtPos('speed', corner.apexPos),
            exitSpeed = lapData:getValueAtPos('speed', corner.endPos),
            brakePos = lapData:findBrakePoint(corner.startPos, corner.apexPos),
            liftOffPos = lapData:findLiftPoint(corner.startPos, corner.apexPos),
            maxSteeringDeg = lapData:findMaxSteering(corner.startPos, corner.endPos)
        }
    end
    return analysis
end

--- Get corner at a specific position
---@param pos number Spline position
---@return table|nil Corner definition
function state.getCornerAt(pos)
    for _, c in ipairs(state.trackCorners) do
        -- Skip corners with nil positions (placeholders for numbering)
        if c.startPos and c.endPos then
            local inside
            if c.startPos <= c.endPos then
                inside = pos >= c.startPos and pos <= c.endPos
            else
                inside = pos >= c.startPos or pos <= c.endPos
            end
            if inside then
                return c
            end
        end
    end
    return nil
end

--- Check if position is in a corner
---@param pos number Spline position
---@return number Corner number or 0
function state.isInCorner(pos)
    local c = state.getCornerAt(pos)
    return c and c.number or 0
end

--- Get corner info by number
---@param num number Corner number
---@return table|nil Corner definition
function state.getCornerInfo(num)
    for _, c in ipairs(state.trackCorners) do
        if c.number == num then
            return c
        end
    end
    return nil
end

--- Get corner numbers for array of positions
---@param positions table Array of spline positions
---@return table Array of corner numbers (0 for not in corner)
function state.getCornersForPositions(positions)
    if not positions or #positions < 1 then return nil end
    local result = {}
    for i = 1, #positions do
        result[i] = state.isInCorner(positions[i])
    end
    return result
end

--- Has manual corners defined
---@return boolean
function state.hasCorners()
    return state.trackCorners and #state.trackCorners > 0
end

--- Get corner count
---@return number
function state.getCornerCount()
    return state.trackCorners and #state.trackCorners or 0
end

--- Clear all corners
function state.clearCorners()
    state.trackCorners = {}
    saveCornersToStorage()
    ac.log("Traces: Cleared corners")
end

--- Save corners to file
---@return boolean
function state.saveCornersToFile()
    return saveCornersToFile()
end

--------------------------------------------------------------------------------
-- Manual Corner Recording
--------------------------------------------------------------------------------

--- Start recording a corner
---@param pos number Current spline position
function state.startCornerRecording(pos)
    state.cornerRecording = true
    state.cornerRecordStart = pos
    state.cornerRecordTime = os.clock()
end

--- Stop recording a corner
---@param pos number Current spline position
---@return boolean True if corner was recorded (not skipped)
function state.stopCornerRecording(pos)
    if not state.cornerRecording then return false end
    
    local holdDuration = os.clock() - state.cornerRecordTime
    
    if holdDuration < TAP_THRESHOLD then
        -- Tap = skip (add empty corner for numbering)
        table.insert(state.trackCorners, {
            number = #state.trackCorners + 1,
            startPos = nil,
            endPos = nil,
            apexPos = nil
        })
        ac.log("Traces: Skipped corner #" .. #state.trackCorners)
    else
        -- Hold = record corner
        local startPos = state.cornerRecordStart
        local endPos = pos
        local apexPos = (startPos + endPos) / 2
        if endPos < startPos then
            apexPos = (startPos + endPos + 1) / 2
            if apexPos >= 1 then apexPos = apexPos - 1 end
        end
        
        table.insert(state.trackCorners, {
            number = #state.trackCorners + 1,
            startPos = startPos,
            endPos = endPos,
            apexPos = apexPos
        })
        ac.log("Traces: Recorded corner #" .. #state.trackCorners)
    end
    
    saveCornersToStorage()
    
    state.cornerRecording = false
    state.cornerRecordStart = nil
    state.cornerRecordTime = nil
    
    return holdDuration >= TAP_THRESHOLD
end

--- Check if currently recording
---@return boolean
function state.isRecordingCorner()
    return state.cornerRecording
end

--------------------------------------------------------------------------------
-- CSV Loading
--------------------------------------------------------------------------------

--- Load lap from CSV and add to references
---@param filePath string Path to CSV file
---@return table|nil Loaded lap
function state.loadCSV(filePath)
    local loaded = lap.fromCSV(filePath, state.track, state.car)
    if loaded then
        table.insert(state.historyReferences, loaded)
        return loaded
    end
    return nil
end

--- Load CSV and set as best lap
---@param filePath string Path to CSV file
---@return boolean Success
function state.loadCSVAsBest(filePath)
    local loaded = lap.fromCSV(filePath, state.track, state.car)
    if loaded then
        state.setBestLap(loaded)
        table.insert(state.historyReferences, loaded)
        return true
    end
    return false
end

return state
